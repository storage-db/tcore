# 动态链接

由于关于RISC-V 动态链接的资料太少，于是我们对于动态链接的学习是基于X86系统的。

## 优势

### 与静态链接对比

1. 空间太浪费。每个库文件在运行时在磁盘和内存上都有多个副本。
2. 对程序的更新，部署，发布带来许多麻烦。比如某个库更新了，需要重新链接发布给用户。

动态链接就是将链接的过程推迟到运行时在进行。使得每个库文件在内存和磁盘上都只有一个副本，共用同一个库内存的好处是减少内存的换入换出，增加 CPU 缓存命中率，程序可扩展性和兼容性强。性能略有下降，但这点性能换来空间节省和灵活性，可接受的。



## 相关技术

### 新增存储段

1. .interp 保存一个字符串，字符串表示的是动态链接器的路径，一般是/lib/ld-linux.so.2
2. .dynamic 动态链接最重要的结构，保存动态链接需要的基本信息，如依赖于哪些对象，动态链接表符合表的位置，动态链接重定位表的位置，共享对象初始化代码的地址。
3. .dynsym 动态链接符号表，只保存与动态链接相关的符号，一般静态链接的符号表.symtab包含.dynsym的内容。
4. .dynstr 动态链接符号字符串表，与静态的strtab对应，往往还有.hash字符哈希表来进行辅助
5. .got与.got.plt .got 用来保存全局变量的引用地址；.got.plt 用来保存函数引用的地址
6. .rel.dyn与.rel.plt 动态链接重定位表，分别相当于静态的，rel.data与rel.text，前者对数据引用修正，修正的位置在.got及数据段；后者对函数引用修正，修正的位置在.got.plt

### 地址无关代码（PIC，Posion-Independent code）

地址无关代码为了解决装载时动态模块有绝对地址引用的问题，且希望共享的部分在装载时可以共享内存，不因装载地址的改变而改变。
由于装载时重定位的指令部分无法共享的确定，由此产生了地址无关码

1. 可以加载而无需重定位的代码称为地址无关码
2.  `GCC` 中使用 `-fPIC` 选项可以得到使用地址无关码的共享对象

对于内部数据/函数的访问，直接通过相对寻址方式在运行前即可确定
对于外部数据/函数，往往意味着对全局变量的访问，对于在全局对象中定义的变量来说，这些符号的地址与模块装载地址有关，ELF 使用 GOT(全局偏移表) 来对这些变量进行间接引用需要在装载时确定。称之为全局偏移表（Global offest Table）。

模块在编译时，可以确定内部变量相对于当前指令的偏移，即编译时可以确定 GOT 的偏移。在加载时，动态链接器会重定位 GOT 中的每个条目，使他们指向正确的地址

对于全局/静态的数据，由于不能事先确定是否引用了外部的库，所以也使用 GOT 处理



### 延迟绑定

即使使用了地址无关代码，动态链接仍存在问题：

1. 对于全局/静态/模块间的数据/函数都需要复杂的GOT定位，耗时。
2. 运行前链接的过程中，会寻找所有的共享对象和函数，耗时。

为了解决第二个问题，提出了延迟绑定，使用PLT（Procedure Linkage Table,过程链接表）实现，基本思想是当函数第一次被用到时才进行绑定（符号查找，重定位等），没有用就不绑定。实现思路是在GOT前再加一层间接跳转，调用函数不通过GOT 直接跳，而是通过 PLT，PLT记录了每个函数对应的地址。
PLT简单实现，假设调用 bar() 函数，在PLT中存在与其对应的bar@plt。
bar@plt初始时存储的是下一条指令的地址，所以初始时会进行一次绑定，之后直接跳转到调用函数的地址。

```BASH
bar@plt:
jmp *(bar@GOT)         		//如果是第一次链接，该语句的效果只是跳转到下一句指令。否则，将会跳转到 bar()函数对应的位置
push n				//压栈 n，n 是 bar 这个符号在重定位表 .rel.plt 中的下标
push moduleID           	// 压栈当前模块的模块ID，上述例子中的 liba.so
jump _dl_runtime_resolve()   	//跳转到动态链接器中的地址绑定处理函数
```

一旦 `bar()` 这个函数被解析完毕，当我们再次调用 `bar@plt` 时，第一条 `jmp` 指令就能够跳转到真正的bar函数中，`bar()`函数返回的时候会根据堆栈里面保存的 EIP 直接返回到调用者，而不会再继续执行 `bar@plt` 中第二条指令开始的那段代码，那段代码只会在符号未被解析时执行一次。

ELF 将 GOT 拆为了两个表叫做" .got "," .got.plt "。其中 .got 用来保存全局变量的引用地址，.got.plt 用来保存函数引用的地址，也就是说，所有对于外部函数的引用被分离到了 .got.plt 表。

![](https://img-1307557302.cos.ap-shanghai.myqcloud.com/img/elfpltgot.png)

## 动态链接过程

### 1. 动态链接器自举

动态链接器是所有动态链接的可执行文件运行时的代码入口，动态链接器本身也是一个共享对象，但它不能依赖于其他对象。

动态链接器入口地址即是自举代码的入口，当操作系统将进程控制权交给动态链接器时，动态链接器的自举代码即开始执行。自举代码首先会找到它自己的 GOT 。而GOT的第一个入口保存的即是" .dynamic "段的偏移地址，由此找到了动态连接器本身的" .dynamic "段。通过" .dynamic "中的信息，自举代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位。从这一步开始，动态链接器代码中才可以开始使用自己的全局变量和静态变量。

### 2. 装载共享对象

从 ELF 文件头和 dynamic 中得到依赖的所有共享对象集合，找到相应的共享对象映射到进程空间，若共享对象有依赖就将依赖的也放入集合中，整个装载的过程是广度优先搜索的过程。当对象被装载后，符号表会合并到全局符号表，当所有的共享对象都装载后，符号表包含所有符合

### 3. 地址重定位和初始化

装载共享对象完成后，链接器开始遍历可执行文件和各个共享对象的重定位表，将 GOT/PLT 的内容进行修正，之后依据地址无关代码和延迟绑定进行重定位。

### 4. 控制权转交

当完成了重定位和初始化之后，所有的准备工作就宣告完成了，所需要的共享对象也都已经装载并且链接完成了，这时候动态链接器就如释重负，将进程的控制权转交给程序的入口，并且开始执行。

## 遗憾

于是我们在进行学习后，得出了以下关于动态链接实现的简要模型

![TCore_动态链接流程](https://img-1307557302.cos.ap-shanghai.myqcloud.com/img/TCore_%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%B5%81%E7%A8%8B.png)

于是我们打算在 TCore 中实践以下模型，但是由于个人原因未有时间进行深一步的实践。



