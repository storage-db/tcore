# 文件系统

文件系统的整体架构自下而上可分为五层：

![文件系统结构](https://img-1307557302.cos.ap-shanghai.myqcloud.com/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg)

整个simple_fat32 文件系统的设计开发可以按照应用程序库的开发过程来完成，因此我们便可通过实现对应的库函数接口来将其直接放到内核中，形成有文件系统支持的新内核。

## 磁盘块设备接口层

最底层就是对块设备的访问操作接口。在 `Tcore/codes/simple_fat32/src/block_dev.rs` 中，可以看到 `BlockDevice` trait ，它代表了一个抽象块设备的接口，该 trait 仅需求两个函数 `read_block` 和 `write_block` ，分别代表将数据从块设备读到内存缓冲区中，或者将数据从内存缓冲区写回到块设备中，数据需要以块为单位进行读写。simple_fat32 库的使用者（如操作系统内核）需要实现块设备驱动程序，并实现 `BlockDevice` trait 以提供给 simple_fat32 库使用，这样 simple_fat32 库就与一个具体的执行环境对接起来了。至于为什么块设备层位于 simple_fat32 的最底层，那是因为文件系统仅仅是在块设备上存储的稍微复杂一点的数据。无论对文件系统的操作如何复杂，从块设备的角度看，这些操作终究可以被分解成若干次基本的块读写操作。

## 块缓存层



尽管在操作系统的最底层（即`/drivers/block/virtio_blk.rs`中的块设备驱动程序）已经有了对块设备的读写能力，但从编程方便/正确性和读写性能的角度来看，仅有块读写这么基础的底层接口是不足以实现高效的文件系统。比如，某应用将一个块的内容读到内存缓冲区，对缓冲区进行修改，并尚未写回块设备时，如果另外一个应用再次将该块的内容读到另一个缓冲区，而不是使用已有的缓冲区，这将会造成数据不一致问题。此外还有可能增加很多不必要的块读写次数，大幅降低文件系统的性能。因此，通过程序自动而非程序员手动地对块缓冲区进行统一管理也就很必要了，该机制被我们抽象为 simple_fat32  自底向上的第二层，即块缓存层。在 `simple_fat32/src/block_cache.rs` 中， `BlockCache` 代表一个被我们管理起来的块缓冲区，它包含块数据内容以及块的编号等信息。当它被创建的时候，将触发一次 `read_block` 将数据从块设备读到它的缓冲区中。接下来只要它驻留在内存中，便可保证对于同一个块的所有操作都会直接在它的缓冲区中进行而无需额外的 `read_block` 。块缓存管理器 `BlockManager` 在内存中管理有限个 `BlockCache` 并实现了类似 FIFO 的缓存替换算法，当一个块缓存被换出的时候视情况可能调用 `write_block` 将缓冲区数据写回块设备。总之，块缓存层对上提供 `get_block_cache` 接口来屏蔽掉相关细节，从而可以向上层子模块提供透明读写数据块的服务。

![内存缓冲区](https://img-1307557302.cos.ap-shanghai.myqcloud.com/img/%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA.png)

## 磁盘数据结构层

磁盘布局层用于组织FAT32特有的数据结构。需要注意的是，K210要求对齐读写，即某类型变量的地址必须以该类型大小对齐。通过查看FAT32文档可知，引导扇区的一些字段是不对齐的，例如半字类型的字段可能与字节对齐。对于这些字段，我们以字节数组的形式读入，设计接口封装其读写以使上层直接使用字段类型控制。
首先介绍引导扇区和扩展引导扇区。他们给出了块设备的基本信息，例如扇区大小数量、簇大小、版本、校验签名、保留扇区数目、文件信息扇区所在位置等。如果设备进行了分区，引导扇区还包含了第一个分区的起始扇区。引导扇区的信息通常不需要修改，他们只负责在文件系统其动时进行校验并为管理层提供相关的信息。事实上，这两个扇区也仅在文件系统起动时会读入。因为这两个扇区的字段较多，我们定义了完整的结构体，将所有字段作为成员，以与磁盘数据一一对应。使用时需从cache读入对应的块，然后将对块的引用转换为对应结构体的引用。

其次是文件系统信息扇区。该扇区有五个重要字段，前两个字段为校验签名，第三个为FS剩余簇数、第四个字段为起始空闲簇、第五个字段为校验签名。显然，第三、四个字段经常需要读写。该扇区的有效字段分布于扇区首尾，中间均为无效字节，为了节约空间，不必建立包含整个扇区字段成员的结构体。我们定义了一个FSInfo结构体，其只包含扇区号这一个成员，但是实现了丰富的接口，包括签名校验，簇信息字段的读写。只保留扇区号一个成员是合理的，因为扇区的读写经由缓存，而缓存的提供的接口只需要扇区号和偏移信息。然后是目录项结构。目录项结构复杂，字段较多，因此依然实现了完整的结构体以与磁盘数据一一对应。FAT32的目录项长32字节，包括长文件名目录项和短文件名目录项两种类型，当文件名较长时，采用多个长名目录项加一个短名目录项的形式存储。文件的所有信息都存储于短名目录项，包括名称、扩展、属性、创建/访问/修改时间、大小、起始簇号等，因此我们将其作为文件的访问入口。对于长短名目录项，我们均设计了丰富的接口以进行封装，这样上层在访问时可以以直观的数据类型读写信息，而不必考虑复杂的内部结构。短名目录项的核心接口如下：



| 接口                  | 描述                                           |
| --------------------- | ---------------------------------------------- |
| initialize            | 以指定的信息初始化目录项                       |
| get_pos               | 获取文件的扇区和偏移                           |
| read_at               | 在指定偏移处读文件                             |
| write_at              | 在指定偏移处写文件，上层模块需保证文件大小足够 |
| as_bytes/as_bytes_mut | 将数据结构转换为字节数组                       |
| checksum              | 计算短文件名的校验和，用于填充长名目录项的字段 |
|                       |                                                |

短名目录项比较简单，其用11个字节存储文件名，包括8字节名称和3字节扩展名，使用ASCII编码。长目录项则使用分散的26个字节存储文件名，使用Unicode编码。为了屏蔽内部的存储细节，我们实现了get_name接口，其以字符串的形式返回目录项中的文件名，便于其他模块使用。最后是FAT，即文件分配表。FAT是FAT类文件系统的核心。在FAT32文件系统中，文件以簇为单位通过链式结构组织，各簇的下一簇号即存储于FAT中。FAT32拥有2个FAT，FAT2作为FAT1的备份，因此写操作需要同步进行，而读操作发现故障时需要及时换到另一FAT。在实现上，我们定义了一个FAT结构体，其包含两个成员，分别是FAT1和FAT2的起始扇区号。由此，对于FAT的一切操作都直接通过缓存进行。我们对FAT实现了丰富的接口，核心接口定义如下：

| 接口               | 描述                                 |
| ------------------ | ------------------------------------ |
| calculate_pos      | 计算簇号对应表项所在的扇区和偏移     |
| next_free_cluster  | 获取可用簇的簇号                     |
| get_next_cluster   | 获取当前簇的下一簇                   |
| set_next_cluster   | 设置当前簇的下一簇                   |
| get_cluster_at     | 获取某个簇链的第 i个簇(i为参数)      |
| final_cluster      | 获取某个簇链的最后一个簇             |
| get_all_cluster_of | 获得某个簇链从指定簇开始的所有簇     |
| count_cluster_num  | 统计某个簇链从指定簇开始到结尾的簇数 |
|                    |                                      |

以上接口实现的算法比简单，主要为反复查询FAT，此处不再赘述。但是通过这样的封装，其他模块可以便捷的对FAT操作。例如，管理模块可以通过接口直观地对簇进行分配和回收，虚拟文件层通过接口可以计算文件或者目录占有的簇数等。



## 磁盘块管理器层

管理器的结构体定义如下：

​                                                                                                ***FAT32Manager***

| 成员                | 描述                                               |
| ------------------- | -------------------------------------------------- |
| block_device        | 块设备的引用，进行磁盘操作                         |
| fsinfo              | 文件系统信息扇区的引用                             |
| sectors_per_cluster | 每个簇的扇区数                                     |
| bytes_per_sector    | 每个扇区的字节数                                   |
| vroot_dirent        | 虚拟根目录项。根目录无目录项，引入以与其他文件一致 |
| root_sec            | 更目录所在簇号                                     |
|                     |                                                    |

 管理器负责的首要任务就是启动文件系统，其需要读取引导扇区的数据并进行校验，然后对数据结构进行简单组织。文件系统的启动流程如下：

![文件系统启动](https://img-1307557302.cos.ap-shanghai.myqcloud.com/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-16514099856632.png)



 对于其他模块而言，管理层提供了实用的工具。但凡需要FAT32相关的计算，或者文件系统的相关信息，都可以调用管理层的接口。其提供的服务包含计算文件起始扇区、拆分长文件名、文件名格式化、短文件名生成、计算文件大小所需簇、获取可用簇、单位转换等等。其中，文件名格式化指将自字符串转换为存储于目录项的字节数组格式，同时对空缺位置进行补全。FAT32在长文件名的情况下以长名目录项+短名目录项的形式存储目录项，短名目录项中的文件名由长文件名压缩而成，常用的压缩方式为：取文件名的前6位+编号+后缀。短文件名生成接口就用于实现该功能。其余接口的算法都比较简易，此处不赘述。

## 索引节点层

站在用户的角度看来，在一个进程中可以使用多种不同的标志来打开一个文件，这会影响到打开的这个文件可以用何种方式被访问。此外，在连续调用 `sys_read/write` 读写一个文件的时候，我们知道进程中也存在着一个文件读写的当前偏移量，它也随着文件读写的进行而被不断更新。这些用户视角中的文件系统抽象特征需要内核来实现，与进程有很大的关系，而 `easy-fs` 文件系统不必涉及这些与进程结合紧密的属性。因此，我们需要将 `easy-fs` 提供的 `Inode` 加上上述信息，进一步封装为 OS 中的索引节点 `OSInode`

~~~Rust
pub struct OSInode {
    readable: bool,
    writable: bool,
    //fd_cloexec: bool,
    inner: Mutex<OSInodeInner>,//记录文件读写偏移量等有用信息
}
~~~

## 文件描述符层



在文件描述符层中，我们将文件抽象为虚拟文件，设计了VFile结构体，其成员包含常见用的文件信息、文件短目录项所在扇区和偏移、FS管理器和块设备接口的引用。上文提及本文件系统以短目录项为访问入口，因此此处的虚拟文件与短目录项对应。以下是VFile对内核提供的重要接口：

| 接口              | 描述                                           |
| ----------------- | ---------------------------------------------- |
| create            | 在当前目录的相对路径下创建文件                 |
| find_vfile_bypath | 查找当前目录下的文件，支持递归查找             |
| read_at           | 在当前文件的指定偏移处读数据                   |
| write_at          | 在当前文件的指定偏移处写数据，会自动完成簇分配 |
| clear             | 清除当前文件                                   |
| ls                | 列举当前目录下的所有文件                       |
| dirent_info       | 获取当前目录下指定目录项的信息                 |
| stat              | 获取当前文件的信息                             |





 

 

 

 